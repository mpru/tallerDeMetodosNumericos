---
title: "Unidad 2: Solución de Ecuaciones No Lineales"
subtitle: "Ejemplos"
output: 
    pdf_document:
      includes:
        in_header: modify_header2.txt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = FALSE, warning = F, fig.align = "center")
```

## Ejemplo: Buscar la raíz negativa de $F(x) = x^2 - 0,5$.

## Aproximaciones sucesivas

1. Buscar un punto inical $x_0$, tabulando y graficando la función $F(x)$. Recordar el Teorema de Bolzano.

<!--
EJEMPLO DE COMO SERIA ESCRIBIR EN DOS COLUMNAS
Los comando begin no se pueden usar directo xq pandoc que es el intermediario entre R y Latex
los confunde. POr eso hay que renombrarlos en modify_header.
Para este documento no necesitaba el modify header pero lo puse para este ejemplo
\twocolbegin
[
All human things are subject to decay. And when fate summons, Monarchs must obey.
]
Hello, here is some text without a meaning.  This text should show what 
a printed text will look like at this place. If you read this text, you will get no information.  Really?  Is there no information?  Is there...Hello, here is some text without a meaning.  This text should show what 
a printed text will look like at this place. If you read this text, you will get no information.  
\twocolend
-->

```{r, results="asis", eval = T}
library(knitr)
# si no hago una tabla antes, no me pone bien los nombre en la proxima
cont <- data.frame(x = numeric(0))
kable(cont, escape = FALSE, col.names = "")
# esa tabla de ariba, no sale, ahora si de enserio
x <- seq(0, -.8, -0.1)
fun.1 <- function(x) x^2 - 0.5
Fx <- fun.1(x)
datos <- data.frame(x, Fx)
colnames(datos) <- c("$x$", "$F(x)=x^2-0,5$")
kable(datos, escape=FALSE)

# tablas buenisimas con kable
# https://stackoverflow.com/questions/45528172/rmarkdown-tables-with-math-notation-and-long-text-within
```

```{r, out.width = "50%"}
library(ggplot2)
library("ggthemes")

xlims <- c(-0.8, 0.2)
xbreaks <- seq(-0.8, 0.2, 0.1)
ybreaks <- seq(-0.6, 0.2, 0.1)

ggplot(data.frame(x = 0), aes(x = x)) + 
    stat_function(fun = fun.1, aes(colour = "Fx"), lwd = 1) +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) +
    scale_x_continuous(limits = xlims, breaks = xbreaks) +
    scale_y_continuous(breaks = ybreaks, labels = round(ybreaks, 1)) +
    theme_gdocs() +
    theme(plot.background=element_blank()) +
    scale_color_manual(name = "", values = c(Fx = "blue"), labels = c(Fx = "F(x)"))
```

El punto inicial puede ser $x_0 = -0.7$.

2. Reescribir la ecuación en la forma $x = f(x)$:

$$
x = x^2 + x -0,5
$$

3. Escribir la fórmula recursiva:

$$
x_{i+1} = f(x_i) = x_i^2 + x_i - 0,5
$$

4. Realizar las iteraciones, con 6 cifras decimales.

```{r}
fixedpoint <- function(fun, x0, tol=1e-07, niter=500){
    ## fixed-point algorithm to find x such that fun(x) == x
    ## assume that fun is a function of a single variable
    ## x0 is the initial guess at the fixed point
    
    xold <- x0
    xnew <- fun(xold)
    for (i in 1:niter) {
        xold <- xnew
        xnew <- fun(xold)
        if ( abs((xnew-xold)) < tol )
            return(xnew)
    }
    stop("exceeded allowed number of iterations")
}

fixedpoint_marcos <- function(fun, x0, tol=1e-07, niter=500, decimales = NA){
    ## fixed-point algorithm to find x such that fun(x) == x
    ## assume that fun is a function of a single variable
    ## x0 is the initial guess at the fixed point
    
    xolds <- x0
    xnews <- fun(xolds)
    err <- xnews - xolds
    if (!is.na(decimales)) {
        xnews <- round(xnews, decimales)
        xolds <- round(xolds, decimales)
        err <- round(err, decimales)
    }
    
    for (i in 1:niter) {

        # calcular nuevo
        xolds[i + 1] <- xnews[i]
        xnew <- fun(xolds[i + 1])
        if (!is.na(decimales)) xnew <- round(xnew, decimales)
        xnews[i + 1] <- xnew
        
        # calcular error
        err[i + 1] <- abs((xnews[i + 1] - xolds[i + 1]))
        if (err[i + 1] < tol)
            return(list(
                res = data.frame(i = 0:i, xi = xolds, ximas1 = xnews, errores = err), 
                x = xnew
                ))
    }
    stop("exceeded allowed number of iterations")
}

funf <- function(x) x^2+x -0.5
res <- fixedpoint_marcos(funf, -0.7, decimales = 6, tol=1e-06)
kable(res$res, escape=FALSE, col.names = c("$i$", "$x_i$", "$x_{i+1}=f(x_i)=x^2_i+x_i-0.5$", "Error"))
```

Vemos que $|x_{13} - x_{12}| < 0.000001$, por lo que podemos dejar de iterar e informar como solución a $x = -0,707107$.

**Interpretación gráfica**

Tengo que agregar los pasos del proceso iterativo en el gráfico.

```{r, out.width = "50%"}
funf <- function(x) x^2 + x - 0.5
xlims <- c(-1, 1)
xbreaks <- seq(-1, 1, 0.2)
ybreaks <- seq(-1, 1.2, 0.2)
ylims <- c(-1, 1.2)

ggplot(data.frame(x = 0), aes(x = x)) + 
    stat_function(fun = funf, aes(colour = "fx"), lwd = 1) +
    stat_function(fun = function(x) x, aes(colour = "identity"), lwd = 1) +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) +
    scale_x_continuous(limits = xlims, breaks = xbreaks) +
    scale_y_continuous(limits = ylims, breaks = ybreaks, labels = round(ybreaks, 1)) +
    theme_gdocs() +
    theme(plot.background=element_blank()) +
    scale_color_manual(name = "", values = c(fx = "blue", identity = "red"), 
                       labels = c(fx = expression(y  == x^2 + x - 0.5), identity = "y = x"))
```

Haciendo zoom:

```{r, out.width = "50%"}
xlims <- c(-.712, -0.698)
xbreaks <- seq(xlims[1], xlims[2], 0.002)
ylims <- xlims #c(-.69, -0.72)
ybreaks <- seq(ylims[1], ylims[2], 0.002)

ggplot(data.frame(x = 0), aes(x = x)) + 
    stat_function(fun = funf, aes(colour = "fx"), lwd = 1) +
    stat_function(fun = function(x) x, aes(colour = "identity"), lwd = 1) +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) +
    scale_x_continuous(limits = xlims, breaks = xbreaks) +
    scale_y_continuous(limits = ylims, breaks = ybreaks, labels = round(ybreaks, 3)) +
    theme_gdocs() +
    theme(plot.background=element_blank()) +
    scale_color_manual(name = "", values = c(fx = "blue", identity = "red"), 
                       labels = c(fx = expression(y  == x^2 + x - 0.5), identity = "y = x"))
```

**Evaluación convergencia**

Considerando el intervalo $[a; b] = [-0,8; -0,6]$:

1. La función $f(x) = x^2 + x -0,5$ es continua en $[a; b]$.
2. $f(x) \in [a; b] \quad \forall x \in [a; b]$ (ver gráfico).
3. $f'$ existe en $(a; b)$ con $|f'(x)| \le m < 1 \quad \forall x \in (a; b)$:

    - $f'(x) = 2 x + 1$
    - $|f'(-0,8)| = 0,6 < 1$
    - $|f'(-0,6)| = 0,2 < 1$

Todo lo anterior lo podemos evaluar gráficamente: 

```{r, out.width = "50%"}
funf <- function(x) 2 * x + 1
xlims <- c(-1, 1)
xbreaks <- seq(-1, 1, 0.2)
ylims <- c(-1, 2.7)
ybreaks <- seq(ylims[1], ylims[2], 0.2)


ggplot(data.frame(x = 0), aes(x = x)) + 
    stat_function(fun = funf, aes(colour = "fx"), lwd = 1) +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) +
    scale_x_continuous(limits = xlims, breaks = xbreaks) +
    scale_y_continuous(limits = ylims, breaks = ybreaks, labels = round(ybreaks, 1)) +
    theme_gdocs() +
    theme(plot.background=element_blank()) +
    scale_color_manual(name = "", values = c(fx = "blue"), 
                       labels = c(fx = expression("f '(x)"  == 2 * x + 1)))
```
    
¿Qué sucede con la otra raíz de $F(x)$? Esta función es simétrica alrededor del 0, por lo que la solución aproximada será $x = 0,707107$. Tomando el intervalo $[ a; b] = [0,6; 0,8]$:

$|f'(x)| \nless 1 \quad \forall x \in (a; b)$

$|f'(0,7)| = 2,4 > 1$

Este método converge para hallar la raíz negativa pero no la positiva.

## Newton-Raphson

1. Buscar un punto inical $x_0$. Elegimos otra vez $x_0 = -0,7$.

2. Hallar las derivadas:

$$F'(x) = 2x$$
$$F''(x) = 2$$

3. Evaluar convergencia:

$$\frac{|F(-0,7)F''(-0,7)|}{[F'(-0,7)]^2} = \frac{|-0,01 \cdot 2|}{1.96} = 0.0102 < 1$$

4. Escribir la fórmula recursiva:

$$
x_{i+1} = x_i - \frac{F(x_i)}{F'(x_i)} = x_i - \frac{x_i^2 - 0,5}{2x_i} = \frac{x_i^2 + 0,5}{2x_i}
$$

5. Realizar las iteraciones, con 6 cifras decimales.

```{r}
# Uso la fc de fixpoint, porque una vez que le paso la funcion recursiva,
# hay que hacer lo mismo, repetirla hasta tener error chico
funf <- function(x) (x^2 + 0.5) / (2 * x)
res <- fixedpoint_marcos(funf, -0.7, decimales = 6, tol=1e-06)
kable(res$res, escape=FALSE, col.names = c("$i$", "$x_i$", "$x_{i+1}=f(x_i)=x^2_i+x_i-0.5$", "Error"))
```

Vemos que con sólo dos iteraciones se logra un error $< 0.000001$, mientras que el método de las aproximaciones sucesivas necesitó 13. Además, también se puede comprobar que N-R converge para hallar la raíz positiva.

**Interpretación gráfica**

Converge tan rápido y son números tan pequeños que no se puede representar. Por eso tomo un valor inicial más alejado: $x_0 = -1.5$

```{r, out.width = "80%"}
res <- fixedpoint_marcos(funf, -1.5, decimales = 6, tol=1e-06)
kable(res$res, escape=FALSE, col.names = c("$i$", "$x_i$", "$x_{i+1}=f(x_i)=x^2_i+x_i-0.5$", "Error"))

datos <- res$res
datos$ystart <- 0
datos$yend <- fun.1(datos$xi)
datos$m <- 2 * datos$xi
datos$h <- -2 * datos$xi^2 + fun.1(datos$xi)
datos$etiq <- paste0("x", 0:(nrow(datos)-1))

xlims <- c(-1.7, -0.6)
xbreaks <- seq(xlims[1], xlims[2], 0.1)

ggplot(datos[1:3, ], aes(x = xi)) + 
    stat_function(fun = fun.1, aes(colour = "Fx"), lwd = 1) +
    # geom_vline(xintercept = 0) + 
    geom_hline(yintercept = 0) +
    scale_x_continuous("x", limits = xlims, breaks = xbreaks) +
    # scale_y_continuous(limits = ylims, breaks = ybreaks, labels = round(ybreaks, 1)) +
    theme_gdocs() +
    theme(plot.background=element_blank()) +
    scale_color_manual(name = "", values = c(Fx = "blue"), labels = c(Fx = "F(x)")) +
    geom_segment(data = datos[1:3, ], aes(x = xi, y = ystart, xend = xi, yend = yend), 
                      lwd = 1, lty = 2, color = "red") +
    geom_abline(aes(slope = m, intercept = h)) +
    annotate("text", x = datos$xi[1:3], y = -0.1, label = datos$etiq[1:3])
```